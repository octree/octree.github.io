---
layout: post
date: 2016-11-22 19:04:45
title: 2016-11-22 19:04:46
disqus: y
---

对于 (G, o), 如果 (G, o) 具有封闭性即：
```
x,y <- G, o(x,y) <- G, 则（G，o）具有封闭性 
```
并且满足结合律，则 （G，o）是`半群`。

如果半群 (G, o) 满足交换律，则 (G, o) 是`可交换半群`

如果对于半群 （G， o），存在单位元 `e` 即

```
任意 x <- G, o(a,e) = a
```

则（G，o）为`幺半群`

如果幺半群 (G, o) 满足交换律，则称之为`可交换幺半群`

正整数 N+， 加减乘除运算:

 (N+, +) 满足封闭性和结合律 => 半群，满足交换律 => 可交换半群，没有单位元 => 不是幺半群

(N+, *) 满足封闭性和结合律 => 半群，满足交换律 => 可交换半群，有单位元 1 => 可交换幺半群

(N+, -) 和 (N+, /) 不具有封闭性，所以不是二元代数系统，所以也不是半群。

## Haskell 

- 如果函数 f 的返回值的类型是 monoid 那么 f 也是 monoid

## Monoid

- `<>` ≡ `mappend` :: Monoid a => a -> a -> a

## Functor

- `<$>` ≡ fmap :: Functor f => (a -> b) -> f a -> f b

### Functor Law

- fmap id == id
- fmap (f.g) = fmap f (fmap g)

## Applicative

1. Applicative 是 幺半群的 Functor
2. 有 Functor 的 type 必有 Applicative

### Applicative Laws

1. pure id <*> v = v
2. pure (.)  <*> u <*> v <*> w == u <*> (v <*> w)
3. pure f <*> pure x = pure (f x)
4. u <*> pure y == pure ($ y) <*> u

## Monad

1. `*>` & `>>` 可用于顺序执行两个函数。
2. `>>=` 绑定，可以认为把封装的值绑定到某个函数中。

### Monad Laws

 1. m >>= return  ≡ m
 2. return x >>=  f  ≡ f x
 3. m >>= f >>= g  ≡ m >>= \x -> f x >>= g 